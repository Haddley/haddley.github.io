---
title: "Raspberry Pi SH1106"
description: "A comprehensive guide covering raspberry pi sh1106"
date: "2025-09-20"
category: "Development"
image: "/assets/images/sh1106/hero.png"
tags: ["python","ml","machine learning"]
---

# Raspberry Pi SH1106

## OLED display

![](/assets/images/sh1106/raspberry-pi-logo.svg)
*Raspberry Pi is a trademark of Raspberry Pi Ltd*


## Raspberry Pi OLED display

The Raspberry Pi can output text (and simple graphics) to an OLED display using Python.

![](/assets/images/sh1106/screen-shot-2023-07-24-at-8.12.44-am-660x528.png)
*OLED wiring*

![](/assets/images/sh1106/screen-shot-2023-07-24-at-8.23.25-am-1140x740.png)
*i2cdetect -y 1*


## Luma-OLED Driver

I installed the Luma-OLED driver by following these instructions:

 [https://luma-oled.readthedocs.io/en/latest/install.html](https://luma-oled.readthedocs.io/en/latest/install.html)

I installed the driver with this command

$ sudo -H pip3 install --upgrade luma.oled

I enabled I2C communications using the raspi-config application

$ sudo raspi-config

Interface Options | I2C | enable ARM I2C


## i2c permissions

I followed the steps described by [Alexander RÃ¼edlinger](https://lexruee.ch/setting-i2c-permissions-for-non-root-users.html) to allow non-root users to access i2c devices (specifically the OLED display).

1) Create new user group called i2c:
**$ sudo groupadd i2c**

2) Change the group ownership of /dev/i2c-1 to i2c:
**$ sudo chown :i2c /dev/i2c-1**

3) Change the file permissions of the device /dev/i2c-1 so users of the i2c group can read and write to the device:
**$ sudo chmod g+rw /dev/i2c-1**

4) Add your user to the group i2c:
**$ sudo usermod -aG i2c <username>**

![](/assets/images/sh1106/screen-shot-2023-07-24-at-8.40.42-am-1140x744.png)
*Python code*

![](/assets/images/sh1106/img-3353-1836x1377.jpg)
*The hello.py code running on configured hardware*


## Displaying an image on the OLED display

I downloaded a stop sign image and updated the hello.py code to display the image on the OLED display.

![](/assets/images/sh1106/20230725-stop-sign-1836x1377.jpg)
*Stop sign*


## Using OpenCV and luma.oled to display video on the OLED display

OpenCV (Open Source Computer Vision Library) is an open-source computer vision and machine learning software library. It provides a comprehensive set of tools and functions that enable developers to perform various computer vision tasks, such as image and video processing, object detection, facial recognition, and feature extraction. 

I used the cv2 library to read frames from a dog video I downloaded from:
[https://pixabay.com/videos/puppy-dog-playful-beach-sand-play-4740/](https://pixabay.com/videos/puppy-dog-playful-beach-sand-play-4740/)

Then I updated the code to send image captured by the webcam to the OLED display.

![](/assets/images/sh1106/20230725-dog-video-1836x1377.jpg)
*Dog video*

![](/assets/images/sh1106/20230725-img-3391-1536x1152.jpg)
*Webcam*


## hello.py

```text
from luma.core.interface.serial import i2c, spi, pcf8574
from luma.core.interface.parallel import bitbang_6800
from luma.core.render import canvas
from luma.oled.device import ssd1306, ssd1309, ssd1325, ssd1331, sh1106, sh1107, ws0010
from time import sleep

# rev.1 users set port=0
# substitute spi(device=0, port=0) below if using that interface
# substitute bitbang_6800(RS=7, E=8, PINS=[25,24,23,27]) below if using that interface
serial = i2c(port=1, address=0x3C)

# substitute ssd1331(...) or sh1106(...) below if using that device
device = sh1106(serial)

with canvas(device) as draw:
    draw.rectangle(device.bounding_box, outline="white", fill="black")
    draw.text((30, 40), "Hello World", fill="white")

sleep(10)
```

## stop_sign_display.py

```text
from luma.core.interface.serial import i2c, spi, pcf8574
from luma.core.interface.parallel import bitbang_6800
from luma.core.render import canvas
from luma.oled.device import ssd1306, ssd1309, ssd1325, ssd1331, sh1106, sh1107
from time import sleep

from PIL import Image

serial = i2c(port=1, address=0x3C)
device = sh1106(serial)

width =  device.width
height = device.height

image = Image.open("stop.png")

image_r = image.resize((width,height), Image.LANCZOS)
# Image.BICUBIC is another option
image_bw = image_r.convert("1")

device.display(image_bw)

sleep(10)
```

## dog_display_window_and_oled.py

```text
from luma.core.interface.serial import i2c, spi, pcf8574
from luma.core.interface.parallel import bitbang_6800
from luma.core.render import canvas
from luma.oled.device import ssd1306, ssd1309, ssd1325, ssd1331, sh1106, sh1107

from time import sleep

import cv2

# OpenCV follows BGR color convention and PIL follows RGB color convention

# Python Imaging Library
from PIL import Image

serial = i2c(port=1, address=0x3C)
device = sh1106(serial)

width =  device.width
height = device.height

cap = cv2.VideoCapture("dog.mp4")
while True:
    ret, frame = cap.read()
    if not ret:
        break
    cv2.imshow("Img", frame)
    
    color_coverted = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    pil_image = Image.fromarray(color_coverted)
    image_r = pil_image.resize((width,height), Image.LANCZOS) 
    # Image.BICUBIC is another option
    image_bw = image_r.convert("1")

    device.display(image_bw)

    key = cv2.waitKey(1)
    if key == 27:
        break
        
cap.release()
cv2.destroyAllWindows()
```

## webcam_display_window_and_oled.py

```text
...
cap = cv2.VideoCapture(0)
...
```

