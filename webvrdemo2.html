<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Underwater AR on Quest 3</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background-color: #000;
      font-family: Arial, sans-serif;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      text-align: center;
    }
    #ar-button {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      background: #1a73e8;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      z-index: 100;
      display: none;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="loading">Loading underwater world...</div>
  <button id="ar-button">START AR</button>
  
  <!-- Load Three.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Built-in ARButton implementation
    const ARButton = {
      createButton: function(renderer, sessionInit = {}) {
        const button = document.getElementById('ar-button');
        
        function showStartAR() {
          button.style.display = '';
          button.textContent = 'START AR';
          button.onclick = null;
        }
        
        function showARNotSupported() {
          button.style.display = '';
          button.textContent = 'AR NOT SUPPORTED';
          button.onclick = null;
        }
        
        function showARNotAllowed() {
          button.style.display = '';
          button.textContent = 'AR NOT ALLOWED';
          button.onclick = null;
        }
        
        function showAREnd() {
          button.style.display = '';
          button.textContent = 'EXIT AR';
        }
        
        function disableButton() {
          button.style.display = 'none';
          button.onclick = null;
        }
        
        function onSessionStarted(session) {
          session.addEventListener('end', onSessionEnded);
          renderer.xr.setSession(session);
          disableButton();
          showAREnd();
          
          button.onclick = function() {
            session.end();
          };
        }
        
        function onSessionEnded() {
          renderer.xr.setSession(null);
          showStartAR();
        }
        
        button.style.display = 'none';
        
        if ('xr' in navigator) {
          navigator.xr.isSessionSupported('immersive-ar').then(function(supported) {
            if (supported) {
              showStartAR();
              
              button.onclick = function() {
                disableButton();
                navigator.xr.requestSession('immersive-ar', sessionInit)
                  .then(onSessionStarted)
                  .catch(function(err) {
                    console.error(err);
                    showARNotAllowed();
                  });
              };
            } else {
              showARNotSupported();
            }
          }).catch(showARNotSupported);
        } else {
          showARNotSupported();
        }
        
        return button;
      }
    };

    // Scene globals
    let camera, scene, renderer;
    let controller, hitTestSource = null;
    let reticle;
    let seaCreatures = [];
    let clock = new THREE.Clock();
    
    // Create a simple animated fish
    function createFish() {
      const fish = new THREE.Group();
      
      // Body (elongated sphere)
      const bodyGeom = new THREE.SphereGeometry(0.3, 16, 16);
      bodyGeom.scale(1.5, 0.7, 0.7);
      const bodyMat = new THREE.MeshPhongMaterial({ 
        color: 0x3399ff,
        transparent: true,
        opacity: 0.8,
        shininess: 100
      });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      fish.add(body);
      
      // Tail (triangle)
      const tailGeom = new THREE.ConeGeometry(0.2, 0.5, 4);
      tailGeom.rotateZ(Math.PI/2);
      const tailMat = new THREE.MeshPhongMaterial({ color: 0x2266cc });
      const tail = new THREE.Mesh(tailGeom, tailMat);
      tail.position.set(-0.5, 0, 0);
      fish.add(tail);
      
      // Eye
      const eyeGeom = new THREE.SphereGeometry(0.05);
      const eyeMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
      const eye = new THREE.Mesh(eyeGeom, eyeMat);
      eye.position.set(0.4, 0.1, 0.3);
      fish.add(eye);
      
      // Animation properties
      fish.userData = {
        speed: 0.5 + Math.random() * 0.5,
        amplitude: 0.5 + Math.random() * 0.3,
        swimOffset: Math.random() * Math.PI * 2
      };
      
      return fish;
    }
    
    // Create a simple animated turtle
    function createTurtle() {
      const turtle = new THREE.Group();
      const shellColor = new THREE.Color(
        0.1 + Math.random() * 0.2,
        0.5 + Math.random() * 0.3,
        0.1 + Math.random() * 0.2
      );
      
      // Shell (flattened sphere)
      const shellGeom = new THREE.SphereGeometry(0.4, 16, 16);
      shellGeom.scale(1.2, 0.6, 1.2);
      const shellMat = new THREE.MeshPhongMaterial({ 
        color: shellColor,
        shininess: 30
      });
      const shell = new THREE.Mesh(shellGeom, shellMat);
      turtle.add(shell);
      
      // Head
      const headGeom = new THREE.SphereGeometry(0.15);
      const headMat = new THREE.MeshPhongMaterial({ color: 0x33aa33 });
      const head = new THREE.Mesh(headGeom, headMat);
      head.position.set(0.4, 0, 0);
      turtle.add(head);
      
      // Legs (flippers)
      for (let i = 0; i < 4; i++) {
        const legGeom = new THREE.CylinderGeometry(0.05, 0.1, 0.2);
        const legMat = new THREE.MeshPhongMaterial({ color: 0x33aa33 });
        const leg = new THREE.Mesh(legGeom, legMat);
        const angle = (i / 4) * Math.PI * 2;
        const radius = 0.3;
        leg.position.set(
          Math.cos(angle) * radius * 0.7,
          -0.3,
          Math.sin(angle) * radius
        );
        leg.rotation.x = Math.PI/2;
        turtle.add(leg);
      }
      
      // Animation properties
      turtle.userData = {
        speed: 0.3 + Math.random() * 0.3,
        amplitude: 0.3 + Math.random() * 0.2,
        swimOffset: Math.random() * Math.PI * 2
      };
      
      return turtle;
    }
    
    // Create a simple animated jellyfish
    function createJellyfish() {
      const jellyfish = new THREE.Group();
      const hue = 0.7 + Math.random() * 0.2; // Purple/pink range
      const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
      
      // Bell (transparent dome)
      const bellGeom = new THREE.SphereGeometry(0.3, 16, 16, 0, Math.PI, 0, Math.PI/2);
      const bellMat = new THREE.MeshPhongMaterial({ 
        color: color,
        transparent: true,
        opacity: 0.6,
        shininess: 100
      });
      const bell = new THREE.Mesh(bellGeom, bellMat);
      bell.position.y = 0.2;
      jellyfish.add(bell);
      
      // Tentacles
      const tentacleCount = 8;
      for (let i = 0; i < tentacleCount; i++) {
        const angle = (i / tentacleCount) * Math.PI * 2;
        const length = 0.5 + Math.random() * 0.3;
        const tentacleGeom = new THREE.CylinderGeometry(0.01, 0.03, length, 8);
        tentacleGeom.translate(0, -length/2, 0);
        const tentacleMat = new THREE.MeshPhongMaterial({ 
          color: color,
          transparent: true,
          opacity: 0.8
        });
        const tentacle = new THREE.Mesh(tentacleGeom, tentacleMat);
        
        tentacle.position.x = Math.cos(angle) * 0.2;
        tentacle.position.z = Math.sin(angle) * 0.2;
        tentacle.position.y = -0.1;
        
        tentacle.rotation.x = Math.PI/2;
        tentacle.rotation.z = angle;
        
        jellyfish.add(tentacle);
      }
      
      // Animation properties
      jellyfish.userData = {
        speed: 0.2 + Math.random() * 0.2,
        amplitude: 0.8 + Math.random() * 0.4,
        swimOffset: Math.random() * Math.PI * 2,
        tentacleOffset: Math.random() * Math.PI * 2
      };
      
      return jellyfish;
    }
    
    // Initialize the scene
    function init() {
      // Create scene with underwater fog effect
      scene = new THREE.Scene();
      scene.background = null; // Transparent for AR
      scene.fog = new THREE.FogExp2(0x0a1a3a, 0.02);
      
      // Add ambient light for soft overall illumination
      const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
      scene.add(ambientLight);
      
      // Add directional light for specular highlights
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 1, 0);
      scene.add(directionalLight);
      
      // Add point light to simulate caustics
      const pointLight = new THREE.PointLight(0x88ccff, 1, 10);
      pointLight.position.set(0, 2, 0);
      scene.add(pointLight);
      
      // Create camera
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
      
      // Create renderer with antialiasing
      renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true,
        powerPreference: "high-performance"
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      // Add XR button
      const button = ARButton.createButton(renderer, { 
        requiredFeatures: ['hit-test'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.body }
      });
      
      // Create controller
      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);
      
      // Create reticle for placement
      reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.1, 0.2, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
      );
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);
      
      // Create initial sea creatures
      createInitialCreatures();
      
      // Hide loading indicator
      document.getElementById('loading').style.display = 'none';
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
      
      // Start animation loop
      renderer.setAnimationLoop(render);
    }
    
    // Create initial set of creatures
    function createInitialCreatures() {
      // Create 3 fish
      for (let i = 0; i < 3; i++) {
        const fish = createFish();
        fish.position.set(
          Math.random() * 4 - 2,
          Math.random() * 2 - 1,
          -3 - Math.random() * 3
        );
        fish.rotation.y = Math.random() * Math.PI * 2;
        scene.add(fish);
        seaCreatures.push(fish);
      }
      
      // Create 2 turtles
      for (let i = 0; i < 2; i++) {
        const turtle = createTurtle();
        turtle.position.set(
          Math.random() * 4 - 2,
          -0.5 + Math.random() * 0.5,
          -4 - Math.random() * 3
        );
        turtle.rotation.y = Math.random() * Math.PI * 2;
        scene.add(turtle);
        seaCreatures.push(turtle);
      }
      
      // Create 3 jellyfish
      for (let i = 0; i < 3; i++) {
        const jellyfish = createJellyfish();
        jellyfish.position.set(
          Math.random() * 4 - 2,
          0.5 + Math.random() * 1,
          -2 - Math.random() * 3
        );
        jellyfish.rotation.y = Math.random() * Math.PI * 2;
        scene.add(jellyfish);
        seaCreatures.push(jellyfish);
      }
    }
    
    // Handle window resize
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Handle controller selection (placing new creatures)
    function onSelect() {
      if (reticle.visible && seaCreatures.length > 0) {
        // Randomly select a creature type to place
        const creatureTypes = [createFish, createTurtle, createJellyfish];
        const createFunc = creatureTypes[Math.floor(Math.random() * creatureTypes.length)];
        const creature = createFunc();
        
        // Position at reticle with random orientation
        creature.position.copy(reticle.position);
        creature.rotation.y = Math.random() * Math.PI * 2;
        
        // Add to scene
        scene.add(creature);
        seaCreatures.push(creature);
      }
    }
    
    // Animate all creatures
    function animateCreatures(time) {
      seaCreatures.forEach((creature, index) => {
        // Skip the first few creatures (they're just for reference)
        if (index < 8) return;
        
        // Get animation properties
        const { speed, amplitude, swimOffset } = creature.userData;
        
        // Swimming motion (sinusoidal movement)
        creature.position.x = Math.sin(time * speed + swimOffset) * amplitude;
        creature.position.z += Math.cos(time * speed * 0.3 + swimOffset) * 0.01;
        
        // Gentle up/down bobbing
        creature.position.y += Math.sin(time * speed * 0.5 + swimOffset) * 0.01;
        
        // Face direction of movement
        const targetRotation = Math.atan2(
          Math.sin(time * speed + swimOffset) * amplitude,
          Math.cos(time * speed + swimOffset) * amplitude
        );
        creature.rotation.y = THREE.MathUtils.lerp(
          creature.rotation.y, 
          targetRotation, 
          0.1
        );
        
        // Special animation for jellyfish tentacles
        if (creature.userData.tentacleOffset !== undefined) {
          creature.children.forEach(child => {
            if (child.geometry instanceof THREE.CylinderGeometry) {
              // Make tentacles wave gently
              child.rotation.x = Math.PI/2 + Math.sin(time * 2 + creature.userData.tentacleOffset) * 0.2;
            }
          });
          
          // Pulsing bell animation
          const bell = creature.children[0];
          const pulse = Math.sin(time * 1.5 + creature.userData.tentacleOffset) * 0.1 + 1;
          bell.scale.set(pulse, pulse, pulse);
        }
      });
    }
    
    // Main render loop
    function render() {
      const time = clock.getElapsedTime();
      
      // Animate creatures
      animateCreatures(time);
      
      // Update reticle position from hit test
      if (renderer.xr.isPresenting && controller) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();
        
        if (session && !hitTestSource) {
          session.requestReferenceSpace('viewer').then((referenceSpace) => {
            session.requestHitTestSource({ space: referenceSpace }).then((source) => {
              hitTestSource = source;
            });
          });
        }
        
        if (hitTestSource) {
          const frame = renderer.xr.getFrame();
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          
          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            const hitPose = hit.getPose(referenceSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(hitPose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }
      
      renderer.render(scene, camera);
    }
    
    // Start the experience
    init();
  </script>
</body>
</html>